【Javaｚ中的锁机制】
Java中存在两种锁机制，分别是synchronized和Lock。Lock接口和实现类是JDK5添加的内容，而synchronized在JDK6开始提供了一系列的锁优化

「Synchronized」
synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。
Synchronized关键字在应用层的语义是可以把任何一个非null对象作为锁
Java中每一个非null对象都可以作为锁，这是synchronized实现同步的基础
1.普通同步方法，锁是当前实例对象；
2.静态同步方法，锁是当前类的class对象；
3.对于同步方法块，锁是synchonized括号里配置的对象。

【sychronized同步的原理】
JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。
代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。
monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， 
JVM要保证每个monitorenter必须有对应的monitorexit与之配对。
任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter指令时
，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。

「volatile」
一个变量如果用volatile修饰了，则Java可以确保所有线程看到这个变量的值是一致的，如果某个线程对volatile修饰的共享变量进行更新，那么其他线程可以立马看到这个更新，这就是所谓的线程可见性。

「并发编程中的三个概念」
并发编程中我们一般都会遇到这三个基本概念：原子性、可见性、有序性。
并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
・【原子性】
即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
i = 0;            ---1
j = i ;            ---2
i++;            ---3
i = j + 1;    ---4
1—在Java中，对基本数据类型的变量和赋值操作都是原子性操作； 
2—包含了两个操作：读取i，将i值赋值给j 
3—包含了三个操作：读取i值、i + 1 、将+1结果赋值给i； 
4—同三一样
在多线程环境下、只有1才是原子操作、Java只保证了基本数据类型的变量和赋值操作才是原子性的

・【可见性】
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
Java提供了volatile来保证可见性。
当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。 

・【有序性】
有序性：即程序执行的顺序按照代码的先后顺序执行。
在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。
Java提供volatile来保证一定的有序性。


一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
※volatile没办法保证对变量的操作的原子性



lock和synchronized的区别对比如下：
1）synchronized 在成功完成功能或者抛出异常时，虚拟机会自动释放线程占有的锁；而Lock对象在发生异常时，如果没有主动调用unLock()方法去释放锁，则锁对象会一直持有，因此使用Lock时需要在finally块中释放锁；
2）lock接口锁可以通过多种方法来尝试获取锁包括立即返回是否成功的tryLock(),以及一直尝试获取的lock()方法和尝试等待指定时间长度获取的方法，比synchronized相对灵活许多;
3) 通过在读多，写少的高并发情况下，我们用ReentrantReadWriteLock分别获取读锁和写锁来提高系统的性能，因为读锁是共享锁，即可以同时有多个线程读取共享资源，而写锁则保证了对共享资源的修改只能是单线程的。

「Semaphore」
Semaphore可以维护访问自身线程个数，并提供了同步机制。使用Semaphore可以控制同时访问资源的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而release() 释放一个许可



